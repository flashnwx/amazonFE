{"ast":null,"code":"import { createVNode as _createVNode } from \"vue\";\nimport { ref, watch, computed, reactive, defineComponent } from \"vue\";\nimport { clamp, numericProp, preventDefault, createNamespace, makeRequiredProp } from \"../utils/index.mjs\";\nimport { useTouch } from \"../composables/use-touch.mjs\";\nimport { useEventListener } from \"@vant/use\";\nimport { Image } from \"../image/index.mjs\";\nimport { Loading } from \"../loading/index.mjs\";\nimport { SwipeItem } from \"../swipe-item/index.mjs\";\n\nconst getDistance = touches => Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);\n\nconst bem = createNamespace(\"image-preview\")[1];\nvar stdin_default = defineComponent({\n  props: {\n    src: String,\n    show: Boolean,\n    active: Number,\n    minZoom: makeRequiredProp(numericProp),\n    maxZoom: makeRequiredProp(numericProp),\n    rootWidth: makeRequiredProp(Number),\n    rootHeight: makeRequiredProp(Number)\n  },\n  emits: [\"scale\", \"close\"],\n\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const state = reactive({\n      scale: 1,\n      moveX: 0,\n      moveY: 0,\n      moving: false,\n      zooming: false,\n      imageRatio: 0,\n      displayWidth: 0,\n      displayHeight: 0\n    });\n    const touch = useTouch();\n    const swipeItem = ref();\n    const vertical = computed(() => {\n      const {\n        rootWidth,\n        rootHeight\n      } = props;\n      const rootRatio = rootHeight / rootWidth;\n      return state.imageRatio > rootRatio;\n    });\n    const imageStyle = computed(() => {\n      const {\n        scale,\n        moveX,\n        moveY,\n        moving,\n        zooming\n      } = state;\n      const style = {\n        transitionDuration: zooming || moving ? \"0s\" : \".3s\"\n      };\n\n      if (scale !== 1) {\n        const offsetX = moveX / scale;\n        const offsetY = moveY / scale;\n        style.transform = `scale(${scale}, ${scale}) translate(${offsetX}px, ${offsetY}px)`;\n      }\n\n      return style;\n    });\n    const maxMoveX = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;\n        return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);\n      }\n\n      return 0;\n    });\n    const maxMoveY = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;\n        return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);\n      }\n\n      return 0;\n    });\n\n    const setScale = scale => {\n      scale = clamp(scale, +props.minZoom, +props.maxZoom + 1);\n\n      if (scale !== state.scale) {\n        state.scale = scale;\n        emit(\"scale\", {\n          scale,\n          index: props.active\n        });\n      }\n    };\n\n    const resetScale = () => {\n      setScale(1);\n      state.moveX = 0;\n      state.moveY = 0;\n    };\n\n    const toggleScale = () => {\n      const scale = state.scale > 1 ? 1 : 2;\n      setScale(scale);\n      state.moveX = 0;\n      state.moveY = 0;\n    };\n\n    let fingerNum;\n    let startMoveX;\n    let startMoveY;\n    let startScale;\n    let startDistance;\n    let doubleTapTimer;\n    let touchStartTime;\n\n    const onTouchStart = event => {\n      const {\n        touches\n      } = event;\n      const {\n        offsetX\n      } = touch;\n      touch.start(event);\n      fingerNum = touches.length;\n      startMoveX = state.moveX;\n      startMoveY = state.moveY;\n      touchStartTime = Date.now();\n      state.moving = fingerNum === 1 && state.scale !== 1;\n      state.zooming = fingerNum === 2 && !offsetX.value;\n\n      if (state.zooming) {\n        startScale = state.scale;\n        startDistance = getDistance(event.touches);\n      }\n    };\n\n    const onTouchMove = event => {\n      const {\n        touches\n      } = event;\n      touch.move(event);\n\n      if (state.moving || state.zooming) {\n        preventDefault(event, true);\n      }\n\n      if (state.moving) {\n        const {\n          deltaX,\n          deltaY\n        } = touch;\n        const moveX = deltaX.value + startMoveX;\n        const moveY = deltaY.value + startMoveY;\n        state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n        state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n      }\n\n      if (state.zooming && touches.length === 2) {\n        const distance = getDistance(touches);\n        const scale = startScale * distance / startDistance;\n        setScale(scale);\n      }\n    };\n\n    const checkTap = () => {\n      if (fingerNum > 1) {\n        return;\n      }\n\n      const {\n        offsetX,\n        offsetY\n      } = touch;\n      const deltaTime = Date.now() - touchStartTime;\n      const TAP_TIME = 250;\n      const TAP_OFFSET = 5;\n\n      if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET && deltaTime < TAP_TIME) {\n        if (doubleTapTimer) {\n          clearTimeout(doubleTapTimer);\n          doubleTapTimer = null;\n          toggleScale();\n        } else {\n          doubleTapTimer = setTimeout(() => {\n            emit(\"close\");\n            doubleTapTimer = null;\n          }, TAP_TIME);\n        }\n      }\n    };\n\n    const onTouchEnd = event => {\n      let stopPropagation = false;\n\n      if (state.moving || state.zooming) {\n        stopPropagation = true;\n\n        if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {\n          stopPropagation = false;\n        }\n\n        if (!event.touches.length) {\n          if (state.zooming) {\n            state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);\n            state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);\n            state.zooming = false;\n          }\n\n          state.moving = false;\n          startMoveX = 0;\n          startMoveY = 0;\n          startScale = 1;\n\n          if (state.scale < 1) {\n            resetScale();\n          }\n\n          if (state.scale > props.maxZoom) {\n            state.scale = +props.maxZoom;\n          }\n        }\n      }\n\n      preventDefault(event, stopPropagation);\n      checkTap();\n      touch.reset();\n    };\n\n    const onLoad = event => {\n      const {\n        naturalWidth,\n        naturalHeight\n      } = event.target;\n      state.imageRatio = naturalHeight / naturalWidth;\n    };\n\n    watch(() => props.active, resetScale);\n    watch(() => props.show, value => {\n      if (!value) {\n        resetScale();\n      }\n    });\n    useEventListener(\"touchmove\", onTouchMove, {\n      target: computed(() => {\n        var _a;\n\n        return (_a = swipeItem.value) == null ? void 0 : _a.$el;\n      })\n    });\n    return () => {\n      const imageSlots = {\n        loading: () => _createVNode(Loading, {\n          \"type\": \"spinner\"\n        }, null)\n      };\n      return _createVNode(SwipeItem, {\n        \"ref\": swipeItem,\n        \"class\": bem(\"swipe-item\"),\n        \"onTouchstartPassive\": onTouchStart,\n        \"onTouchend\": onTouchEnd,\n        \"onTouchcancel\": onTouchEnd\n      }, {\n        default: () => [slots.image ? _createVNode(\"div\", {\n          \"class\": bem(\"image-wrap\")\n        }, [slots.image({\n          src: props.src\n        })]) : _createVNode(Image, {\n          \"src\": props.src,\n          \"fit\": \"contain\",\n          \"class\": bem(\"image\", {\n            vertical: vertical.value\n          }),\n          \"style\": imageStyle.value,\n          \"onLoad\": onLoad\n        }, imageSlots)]\n      });\n    };\n  }\n\n});\nexport { stdin_default as default };","map":{"version":3,"names":["createVNode","_createVNode","ref","watch","computed","reactive","defineComponent","clamp","numericProp","preventDefault","createNamespace","makeRequiredProp","useTouch","useEventListener","Image","Loading","SwipeItem","getDistance","touches","Math","sqrt","clientX","clientY","bem","stdin_default","props","src","String","show","Boolean","active","Number","minZoom","maxZoom","rootWidth","rootHeight","emits","setup","emit","slots","state","scale","moveX","moveY","moving","zooming","imageRatio","displayWidth","displayHeight","touch","swipeItem","vertical","rootRatio","imageStyle","style","transitionDuration","offsetX","offsetY","transform","maxMoveX","value","max","maxMoveY","setScale","index","resetScale","toggleScale","fingerNum","startMoveX","startMoveY","startScale","startDistance","doubleTapTimer","touchStartTime","onTouchStart","event","start","length","Date","now","onTouchMove","move","deltaX","deltaY","distance","checkTap","deltaTime","TAP_TIME","TAP_OFFSET","clearTimeout","setTimeout","onTouchEnd","stopPropagation","reset","onLoad","naturalWidth","naturalHeight","target","_a","$el","imageSlots","loading","default","image"],"sources":["/Users/niweixing/Downloads/web-code/node_modules/vant/es/image-preview/ImagePreviewItem.mjs"],"sourcesContent":["import { createVNode as _createVNode } from \"vue\";\nimport { ref, watch, computed, reactive, defineComponent } from \"vue\";\nimport { clamp, numericProp, preventDefault, createNamespace, makeRequiredProp } from \"../utils/index.mjs\";\nimport { useTouch } from \"../composables/use-touch.mjs\";\nimport { useEventListener } from \"@vant/use\";\nimport { Image } from \"../image/index.mjs\";\nimport { Loading } from \"../loading/index.mjs\";\nimport { SwipeItem } from \"../swipe-item/index.mjs\";\nconst getDistance = (touches) => Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);\nconst bem = createNamespace(\"image-preview\")[1];\nvar stdin_default = defineComponent({\n  props: {\n    src: String,\n    show: Boolean,\n    active: Number,\n    minZoom: makeRequiredProp(numericProp),\n    maxZoom: makeRequiredProp(numericProp),\n    rootWidth: makeRequiredProp(Number),\n    rootHeight: makeRequiredProp(Number)\n  },\n  emits: [\"scale\", \"close\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const state = reactive({\n      scale: 1,\n      moveX: 0,\n      moveY: 0,\n      moving: false,\n      zooming: false,\n      imageRatio: 0,\n      displayWidth: 0,\n      displayHeight: 0\n    });\n    const touch = useTouch();\n    const swipeItem = ref();\n    const vertical = computed(() => {\n      const {\n        rootWidth,\n        rootHeight\n      } = props;\n      const rootRatio = rootHeight / rootWidth;\n      return state.imageRatio > rootRatio;\n    });\n    const imageStyle = computed(() => {\n      const {\n        scale,\n        moveX,\n        moveY,\n        moving,\n        zooming\n      } = state;\n      const style = {\n        transitionDuration: zooming || moving ? \"0s\" : \".3s\"\n      };\n      if (scale !== 1) {\n        const offsetX = moveX / scale;\n        const offsetY = moveY / scale;\n        style.transform = `scale(${scale}, ${scale}) translate(${offsetX}px, ${offsetY}px)`;\n      }\n      return style;\n    });\n    const maxMoveX = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;\n        return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);\n      }\n      return 0;\n    });\n    const maxMoveY = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;\n        return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);\n      }\n      return 0;\n    });\n    const setScale = (scale) => {\n      scale = clamp(scale, +props.minZoom, +props.maxZoom + 1);\n      if (scale !== state.scale) {\n        state.scale = scale;\n        emit(\"scale\", {\n          scale,\n          index: props.active\n        });\n      }\n    };\n    const resetScale = () => {\n      setScale(1);\n      state.moveX = 0;\n      state.moveY = 0;\n    };\n    const toggleScale = () => {\n      const scale = state.scale > 1 ? 1 : 2;\n      setScale(scale);\n      state.moveX = 0;\n      state.moveY = 0;\n    };\n    let fingerNum;\n    let startMoveX;\n    let startMoveY;\n    let startScale;\n    let startDistance;\n    let doubleTapTimer;\n    let touchStartTime;\n    const onTouchStart = (event) => {\n      const {\n        touches\n      } = event;\n      const {\n        offsetX\n      } = touch;\n      touch.start(event);\n      fingerNum = touches.length;\n      startMoveX = state.moveX;\n      startMoveY = state.moveY;\n      touchStartTime = Date.now();\n      state.moving = fingerNum === 1 && state.scale !== 1;\n      state.zooming = fingerNum === 2 && !offsetX.value;\n      if (state.zooming) {\n        startScale = state.scale;\n        startDistance = getDistance(event.touches);\n      }\n    };\n    const onTouchMove = (event) => {\n      const {\n        touches\n      } = event;\n      touch.move(event);\n      if (state.moving || state.zooming) {\n        preventDefault(event, true);\n      }\n      if (state.moving) {\n        const {\n          deltaX,\n          deltaY\n        } = touch;\n        const moveX = deltaX.value + startMoveX;\n        const moveY = deltaY.value + startMoveY;\n        state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n        state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n      }\n      if (state.zooming && touches.length === 2) {\n        const distance = getDistance(touches);\n        const scale = startScale * distance / startDistance;\n        setScale(scale);\n      }\n    };\n    const checkTap = () => {\n      if (fingerNum > 1) {\n        return;\n      }\n      const {\n        offsetX,\n        offsetY\n      } = touch;\n      const deltaTime = Date.now() - touchStartTime;\n      const TAP_TIME = 250;\n      const TAP_OFFSET = 5;\n      if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET && deltaTime < TAP_TIME) {\n        if (doubleTapTimer) {\n          clearTimeout(doubleTapTimer);\n          doubleTapTimer = null;\n          toggleScale();\n        } else {\n          doubleTapTimer = setTimeout(() => {\n            emit(\"close\");\n            doubleTapTimer = null;\n          }, TAP_TIME);\n        }\n      }\n    };\n    const onTouchEnd = (event) => {\n      let stopPropagation = false;\n      if (state.moving || state.zooming) {\n        stopPropagation = true;\n        if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {\n          stopPropagation = false;\n        }\n        if (!event.touches.length) {\n          if (state.zooming) {\n            state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);\n            state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);\n            state.zooming = false;\n          }\n          state.moving = false;\n          startMoveX = 0;\n          startMoveY = 0;\n          startScale = 1;\n          if (state.scale < 1) {\n            resetScale();\n          }\n          if (state.scale > props.maxZoom) {\n            state.scale = +props.maxZoom;\n          }\n        }\n      }\n      preventDefault(event, stopPropagation);\n      checkTap();\n      touch.reset();\n    };\n    const onLoad = (event) => {\n      const {\n        naturalWidth,\n        naturalHeight\n      } = event.target;\n      state.imageRatio = naturalHeight / naturalWidth;\n    };\n    watch(() => props.active, resetScale);\n    watch(() => props.show, (value) => {\n      if (!value) {\n        resetScale();\n      }\n    });\n    useEventListener(\"touchmove\", onTouchMove, {\n      target: computed(() => {\n        var _a;\n        return (_a = swipeItem.value) == null ? void 0 : _a.$el;\n      })\n    });\n    return () => {\n      const imageSlots = {\n        loading: () => _createVNode(Loading, {\n          \"type\": \"spinner\"\n        }, null)\n      };\n      return _createVNode(SwipeItem, {\n        \"ref\": swipeItem,\n        \"class\": bem(\"swipe-item\"),\n        \"onTouchstartPassive\": onTouchStart,\n        \"onTouchend\": onTouchEnd,\n        \"onTouchcancel\": onTouchEnd\n      }, {\n        default: () => [slots.image ? _createVNode(\"div\", {\n          \"class\": bem(\"image-wrap\")\n        }, [slots.image({\n          src: props.src\n        })]) : _createVNode(Image, {\n          \"src\": props.src,\n          \"fit\": \"contain\",\n          \"class\": bem(\"image\", {\n            vertical: vertical.value\n          }),\n          \"style\": imageStyle.value,\n          \"onLoad\": onLoad\n        }, imageSlots)]\n      });\n    };\n  }\n});\nexport {\n  stdin_default as default\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}